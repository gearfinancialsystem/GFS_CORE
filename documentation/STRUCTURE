- CHAQUE 'TERM' appartient a un groupe tel que defini dans la norme
- Chaque 'TERM' est definie par un Struct enveloppante ; evitant que les termes soient definies seulement par des types
    primitifs qui creent de lambiguite
- Les types primitifs autorisés, au sens de la norme, :
    - f64 ("Real")
    - IsoDatetime ("TimeStamp")
    - IsoPeriod ("Period")
    - IsoCycle ("Cycle")
    - String ("VarChar")
    - bool ("bool")
    - Enum ("Enum") (a)
- (a) les enums sont des structures plus complexe a implementer séparéments
- Certains termes sont des 'Array' de terms ou de 'Array' d'éléments non-terms : dans ce cas le plus propre est de definir les
    éléments (deja defini si c'est des termes, non encore definis si c'est des non-term) puis de les wrapper dans un Vec.
    Les Arrays peuvent également contenir des variants denum (Enum[])

- Chaque term doit avoir un trait 'marker' permettant d'identifier quelle famille de type primitif il enveloppe :
  - TraitMarqueurF64
  - TraitMarqueurIsoDatetime
  - TraitMarqueurIsPeriod
  - TraitMarqueurIsoCycle
  - TraitMarqueurString
  - TraitMarqueurBool
  - TraitMarqueurEnum <- beaucoup de methodes specifiques sont a implementer indépendament
  - TraitMarqueurArr : les elements doivent avoir l'un des traits marqueur ci-dessus

- Avoir ces TraitMarqueur nous aide notamment a implementer des conversion explicite entre deux terms ayant le meme
    type primitif sous-jacent


- CHAQUE 'TERM' doit venir avec un certain nombre de methodes, definis dans un trait
- Comme il y a beaucoup de termes, et beaucoup avec une structure similaire, les macros suivantes sont utilisees pour
    generer le code :
    - macro_struct_f64              pour representer les struct du type MaStruct(f64)
        f64 peut venir avec des conditions de validite et/ou des valeurs par default
    - macro_struct_isocycle         pour representer les struct du type MaStruct(IsoCycle)
    - macro_struct_isodatetime      pour representer les struct du type MaStruct(IsoDatetime)
    - macro_struct_isoperiod        pour representer les struct du type MaStruct(IsoPeriod)
    - macro_struct_vec_isodatetime
    - macro_struct_vec_isocycle
    - macro_struct_vec_f64




il faut implemter le trait Display pour pouvoir utiliser to_string


dans les fichiers de tests, tous ce qui commence par Array ou tout ce qui est cense etre un
array doit etre saisi comme tel, exemple :
"arrayCycleAnchorDateOfInterestPayment": "2021-01-01T00:00:00",
doit etre ecrit : "arrayCycleAnchorDateOfInterestPayment": ["2021-01-01T00:00:00"],

"creditEventTypeCovered": "DF", doit etre ecrit "creditEventTypeCovered": ["DF"],

pour eviter toute ambiguite quant au type

A FAIRE :
les supertraits : faire en sorte que TraitisodateTime soit un supertrait de Partialeq, clone, debug ect
et n'appeler que Traitisodatetime


NotionalPrincipal doit etre positive dans la norme (pour qui ne concerne qu'en fait que Model) et peut etre négatif en statespace;
Pour le moment j'enleve la contrainte de positivite ; mais peut etre creer des termes specifiques pour les champs de state_space
jai desactivé la positivité pour ces types, mais faudra la reactiver et recrire le netting des deux jambes de swaps (en soustrayant
deux notionels positifs plutot que dadditioner un positif et un négatif)


observer: DataObserver, // mettre au pluriel pour quon puisse contruire plusieur different dataobserver


que peux contenir Contract Structure ?

AD = Aucun
ANN = Aucun
CAPFL = ContractModel (car il y a un champs contract type)
CEC = ContractModel (car il y a un champs contract type)
CEG = ContractModel ou ContractIdentifier (un contract existant.. il doit y avoir un eventsObserved )
CLM = Aucun
COM = Aucun
CSH = aucun
FUTUR = MarketObjectCode (Sous jacent... il doit y avoir un dataObserved)
FXOUT = Aucun
LAM = Aucun
LAX = Aucun
NAM = Aucun
OPTNS = MarketObjectCode (Sous jacent... il doit y avoir un dataObserved)
PAM = Aucun
STK = Aucun
SWAPS = ContractModel (car il y a un champs contract type)
SSPPV = Aucun
UMP = Aucun


dataObserved
eventsObserved